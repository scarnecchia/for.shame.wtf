import { allocUnsafe as _allocUnsafe, concatArrayBuffers as _concat } from 'bun';
import { Buffer as NodeBuffer } from 'node:buffer';
import { hash as _hash, timingSafeEqual as _timingSafeEqual } from 'node:crypto';
const _compare = /*#__PURE__*/ NodeBuffer.prototype.compare;
const _equals = /*#__PURE__*/ NodeBuffer.prototype.equals;
const _utf8Slice = /*#__PURE__*/ NodeBuffer.prototype.utf8Slice;
const _utf8Write = /*#__PURE__*/ NodeBuffer.prototype.utf8Write;
const toUint8Array = (buffer) => {
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};
export const alloc = (size) => {
    return new Uint8Array(size);
};
export const allocUnsafe = _allocUnsafe;
export const compare = (a, b) => {
    return _compare.call(a, b);
};
export const equals = (a, b) => {
    return _equals.call(a, b);
};
export const timingSafeEquals = (a, b) => {
    return _timingSafeEqual(a, b);
};
export const concat = (arrays, size) => {
    // Bun's typings is slightly wrong, *you can* pass `size: undefined` with `asUint8Array: true`
    return _concat(arrays, size, true);
};
export const encodeUtf8Into = (to, str, offset, length) => {
    return _utf8Write.call(to, str, offset, length);
};
export const decodeUtf8From = (from, offset = 0, length = from.length) => {
    return _utf8Slice.call(from, offset, offset + length);
};
export const toSha256 = async (buffer) => {
    return toUint8Array(_hash('sha256', buffer, 'buffer'));
};
//# sourceMappingURL=index.bun.js.map